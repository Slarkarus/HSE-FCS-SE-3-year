= Лекция 1. Тема лекции [ТРЕБУЕТ ДОРАБОТКИ]
== Представления программ. 
=== Абстрактное синтаксическое дерево.

AST -- структурированное представление программы в терминах языковых конструкций.

+ АСД пригодно для автоматического анализа
+ Содержит высокоуровневую семантическую информацию
+ Удообно для интерпретирования
+ Неудобно для выполнения сложных оптимизирующий преобразований и генерации кода.

Высокоуровневая информация прокидывается в промежуточное (Middle IR. MIR) что не очень удобно, но иначе нельзя, а так удобнее анлизировать.

=== Последовательность инструкций

*LLVM IR* -- промежуточное представление программы.
// TODO:
Каждая интсрукция обладает регулярной формой.

=== Промежуточное представление MIR

У нас будет учебное промежуточное представление, чтобы показать 

+ x = y OP Z
+ x = OP y
+ x = y
+ x[i] = y
+ x = y[i]
+ goto
+ if ...
// TODO:
+ Функции
  + function f(p_1, p_2, ..., p_n)
  + call f(p1, p2, ..., p_n)
  + ret t


=== Пример функции быстрой сортировки

// TODO: вставить картинки

=== Чуть более удобное представление

Граф потока управления -- набор базовых блоков 

Базовый блок -- последовательность инструкций не содержащая инструкций передачи управления (условных, безусловных, возврата из функции).

Также в базовый блок можно войти только в первую инструкцию. В другую -- нельзя.

=== Алгоритм построения графа потока управления

Вход: последовательность трехадресных инструкций

Выход: список баховых блоков

Метод:
+ Строится упорядоченное множество НББ (начал базовых блоков)
+ 
+ 

=== Промежуточное представление MIR

// TODO: вставить картиночки

== Локальная оптимизация (оптмизация базовых блоков)

Оптимизации бывают:

+ Локальные (На уровне BB -- Basic block)
+ Глобальные (На уровне CFG -- control flow graph)
+ LTO (возможно успеем в конце курса)

Локальная оптимизация -- устранение избыточностей в рамках одного базового блока.

=== Пример локальной Оптимизации

// TODO: Вставить картиночушечки

=== Постановка задачи локальной оптимизации

Базовый блок -- множества:

B = \<P, Input, Output>

P -- последовательность инструкций.

Input -- множество переменных, определенных до блока B

Output -- множество переменных, используемых после выхода из блока B

Оптимизация, в ББ это:

- Удаление общих подвыражений.
- Удаление мертвого кода
- Сворачивание констант
- Изменение порядка инструкций, там, гле это возможно, чтобы сократить время хранения временного значения на регистре.

=== Представление базового блока в виде ориентированного ациклического графа

// TODO: вставить картинку

$ a + a * (b - c) + (b - c) * d $

AST -> DAG.

В DAG -- каждое значение представляется только раз. Узлы представляющие в АСД разные значения -- склеиваются.

// TODO: второй пример

$ a = a + y * (b + (y - z) * b) + (y - z) * b $

Как мы это программно решаем? Делаем хэш таблицу поддеревьев. (ХЭШИ!)

=== Метод нумерации значений (SSA алгоритм, но внутри одного блока)

// TODO:

=== Алгортм построения ОАГ для базового блока B

// TODO:

*Представление ОАГ в виде таблицы значений. Пример 1*

Присоединённая переменная -- переменная в левой части присваивания.

// Через %0_5 и %4_5 обозначается что %0 и %4 одинаково вычисляются! 