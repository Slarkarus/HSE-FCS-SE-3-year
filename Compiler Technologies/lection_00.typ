= Лекция 0. Вводная лекция [ТРЕБУЕТ ДОРАБОТКИ]

== О курсе

=== Лектор

Иван Иванович 

=== Элементы контроля

14 лекций, 14 семинаров

4 кр и 6 домашек

Домашки сдаются через ejudje + сдача семеру

4 контрольные в сумме дают 100 баллов

Блокируются контрольные суммы или каждая в отдельности -- неизвестно (на усмотрение лектора)

+ 20
+ 30
+ 30
+ 20

6 домашек тоже 100 баллов, весят:
+ 5
+ 10
+ 15
+ 15
+ 15
+ 40

Итоговая оценка это $ 0,4 * О_("кр") + 0,6 * О_("дз") $

=== Литература

#link("https://github.com") // TODO:
#link("https://github.com")
#link("https://github.com")

== Транслятор, компилятор, интерпретатор

Это 3 программы. В чём их отличие?

*Транслятор* преобразует один язык на другой язык.

*Компилятор* преобразует программу в машинный код.

*Интерпретатор* исполняет исходную программу.

*Гибридный компилятор* сначала транслирует код в байт-код, а затем исполняет. // qemu

Например в _java_, сначала транслятор преобразует код в байт-код, а затем _java virtual machine (JVM)_ исполняет байт-код.

== Виды компиляторов.

AOT (ahead of time) -- полная траснялция программы до её выполнения.

JIT (just in time) -- выполняет динамическую трансляцию промежуточного кода (байт-кода) в исполняемый код целевой архитектуры.

=== Гетерогенный компилятор 

Гетерогенный компилятор -- выполняет трансляцию программы с частями на разных языках (диалектах) для разных целевых архитектур.

Примеры:

Код разделяется на код хоста и код устройства

+ C/С++/Fortran + директивы для расспаралеливания
+ C/С++ + NVIDIA CUDA
+ C/С++ + OpenCL
+ SYCL

*Кросс-компиляция* -- трансляция программы под архитектуру процессора, отличающуюся от архитекуты процессора, на котором выполняется компиляция.

+ Сборка на x86-64 для ARMv8
+ Сборка на x86-64 (little-endian) для (big-endian)
+ Сборка на x86-64 для // TODO: дописать

Если архитектура хоста не совпадает с архитектурой целевого устройства.

=== Почему интересны компиляторы?

Компилятор -- большая и сложная программа.

Там куча интересных алгоритмов. 

 // TODO: Перенести
+
+
+
+
+
+

=== Набор инструметов для программирования (Toolchain)

main.cpp $->$ компилятор // TODO:

Мы будем изучать только блочок компилятор 

Заглянем в компилятор

== Структура компилятора // TODO:

Лексический анализ, препроцессинг, синтаксический анализ, семантический анализ

Чем отличается абстрактное синтаксическое дерево от конкретного синтаксическое дерево? 

AST -- синтаксическое дерево в терминах языковых конструкций

Конкретного синтаксическое дерево -- в терминах результирующего кода

Такое AST поступает в оптимизирующий компилятор

#table(columns: 1)[
  Инструкция
]

=== Задачи компилятора
 // TODO:
Frontend
+ ....
+ Построение HIR

=== Краткий обзор процесса компиляции
В чем разница между токеном и лексемой? Лексема -- последовательность символов. Токен это уже определенная последовательность символов, чем она является

Нисходящий анализ в промышленных компиляторах.

Семантический енализтор -- условно проверяет совместимость типов, корректность сгенерированного кода.

// TODO: В чём отличие машинного представления от ассемблера?