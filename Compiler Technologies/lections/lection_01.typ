= Лекция 1. Тема лекции [ТРЕБУЕТ ДОРАБОТКИ]
== Представления программ. 
=== Абстрактное синтаксическое дерево.

AST -- структурированное представление программы в терминах языковых конструкций.

+ АСД пригодно для автоматического анализа
+ Содержит высокоуровневую семантическую информацию
+ Удообно для интерпретирования
+ Неудобно для выполнения сложных оптимизирующий преобразований и генерации кода.

Высокоуровневая информация прокидывается в промежуточное (Middle IR. MIR) что не очень удобно, но иначе нельзя, а так удобнее анлизировать.

=== Последовательность инструкций

*LLVM IR* -- промежуточное представление программы.
// TODO:
Каждая интсрукция обладает регулярной формой.

=== Промежуточное представление MIR

У нас будет учебное промежуточное представление, чтобы показать 

+ x = y OP Z
+ x = OP y
+ x = y
+ x[i] = y
+ x = y[i]
+ goto
+ if ...
// TODO:
+ Функции
  + function f(p_1, p_2, ..., p_n)
  + call f(p1, p2, ..., p_n)
  + ret t


=== Пример функции быстрой сортировки

// TODO: вставить картинки

=== Чуть более удобное представление

Граф потока управления -- набор базовых блоков 

Базовый блок -- последовательность инструкций не содержащая инструкций передачи управления (условных, безусловных, возврата из функции).

Также в базовый блок можно войти только в первую инструкцию. В другую -- нельзя.

=== Алгоритм построения графа потока управления

Вход: последовательность трехадресных инструкций

Выход: список баховых блоков

Метод:
+ Строится упорядоченное множество НББ (начал базовых блоков)
+ 
+ 

=== Промежуточное представление MIR

// TODO: вставить картиночки

== Локальная оптимизация (оптмизация базовых блоков)

Оптимизации бывают:

+ Локальные (На уровне BB -- Basic block)
+ Глобальные (На уровне CFG -- control flow graph)
+ LTO (возможно успеем в конце курса)

Локальная оптимизация -- устранение избыточностей в рамках одного базового блока.

=== Пример локальной Оптимизации

// TODO: Вставить картиночушечки

=== Постановка задачи локальной оптимизации

Базовый блок -- множества:

B = \<P, Input, Output>

P -- последовательность инструкций.

Input -- множество переменных, определенных до блока B

Output -- множество переменных, используемых после выхода из блока B

Оптимизация, в ББ это:

- Удаление общих подвыражений.
- Удаление мертвого кода
- Сворачивание констант
- Изменение порядка инструкций, там, гле это возможно, чтобы сократить время хранения временного значения на регистре.

=== Представление базового блока в виде ориентированного ациклического графа

// TODO: вставить картинку

$ a + a * (b - c) + (b - c) * d $

AST -> DAG.

В DAG -- каждое значение представляется только раз. Узлы представляющие в АСД разные значения -- склеиваются.

// TODO: второй пример

$ a = a + y * (b + (y - z) * b) + (y - z) * b $

Как мы это программно решаем? Делаем хэш таблицу поддеревьев. (ХЭШИ!)

=== Метод нумерации значений (SSA алгоритм, но внутри одного блока)

// TODO:

=== Алгортм построения ОАГ для базового блока B

// TODO:

*Представление ОАГ в виде таблицы значений. Пример 1*

Присоединённая переменная -- переменная в левой части присваивания.

// Через %0_5 и %4_5 обозначается что %0 и %4 одинаково вычисляются! 

// TODO: Вставит ькартинку второго примера

$
  B = <P, {p, q, r},
          {s, t, u}>
$

$
  P = {\
    s = p + q \
    t = s + r \
    t = p + q \ 
    u = t - q \
  }
$

Для этого примера одной только хэш таблицы значений недостаточно, нужна ещё и *LiveNow* таблица, чтобы отслеживать последнее живое имя каждой из переменных.
#figure(
  table(
    columns: (auto, auto, auto, auto, auto, auto),
    rows: (auto),
    table.header([*p*], [*q*], [*r*], [*s*], [*t*], [*u*]),
    [1], [2], [3], [4], [5], [6],
    [ ], [ ], [ ], [ ], [4], [ ] 
  )
)

=== Снижение стоимости выччислений.

$ x^2$ дороже чем $x*x$ зачастую.

// TODO: вставить остальные примеры

В целом так не везде делают, так как зачастую это зависит от целевой архитектуры процессора.

$ x * 81 = \
 = x * 9 * 9 = \
 = ... = \
 = ((x << 3) + x) << 3 + ((x << 3) + x) << 3 = \
 = ("r1" << 3) + "r1"
$

В результате получается всего 2 такта, что удешевляет исходную дорогую операцию $*81$. 

=== Удаление мёртвого кода.

Те переменные, которые определены в текущем ББ, и не приндлежат множеству *Output*, мы определяем зря!

=== Восстановление базового блока по ОАГ

// TODO: Пример 6

// TODO: Пример 7

В чём проблема в примере? Какой случай верный? Оба неверны!

У нас есть 2 способа решить эту проблему.

1. Ничего не оптимизировать
2. Построить SSA форму.

// TODO: Вставить картинку

Проблема второго подхода такова: мы переименовали переменные в текущем блоке, а во вне переменные (которые попадают в _Output_) используют старое имя переменной.
- Либо в конце обратно имя присваиваем переменной.
- Либо пишем функцию которая возвращает последнее актуальное имя переменной.

// TODO: Спам картинками!

#figure(
  table(
    columns: (auto,auto,auto,auto,auto,auto),
    [*a*],[*b*],[*c*],[*d*],[*t*],[*u*],
    [2], [3], [5], [1], [4], [7],
    [ ], [ ], [ ], [4], [6], [ ],
    [ ], [ ], [ ], [8], [], [ ]      
  )
)






















